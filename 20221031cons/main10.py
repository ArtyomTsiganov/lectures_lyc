import sys

"""_summary_
Запоминаем задачи в файл

Использование:
Добавить задачу
python main.py --add Поучаствовать в олимпиаде --dt 2022-11-02T14:00:00 --label олимпиада
Список задач
python main.py --list
Удалить задачу
python main.py --del олимпиада
"""

"""
0. Код линеен, с сильной взаимозависимостью скорее всего его сложно будет изменять. 
Отсюда нобходиомсть делить код на части. 
Вынесли функции
Создали структуру данных для параметров

1. Классы могут быть использованы как собственные типы данных
2. Классы позволяют объединять кода и данные относящиеся к одной подзадачи и тесно связанные друг с другом.
3. С помощью классов можно разделять внутреннюю логику и внешний интерфейс, внутренняя логика можно произвольным
образом меняться от версии класса (библиотеки классов) к версии, а внешний интерфейс при это оставаться
постоянным, для поддержки всех программистов которые используют эту библиотеку.
"""


# Аналогично можно отрефакторить код этих трех функций
# например для начала написать комментарии низкого уровня описывающие каждое действие
# но даже из них мы уже узнаем что функция сильно связывает разные слабо связанные объекты
# файл и экран
# наверное стоит вынести работу с этими объектами в разные функции
def list_f(param):
    """
    Получить список задач
    :param param:
    :return:


    list_tasks = load_list_from_file(param)
    view_tasks(list_tasks)
    """
    # открыть файл
    # считать строчки
    # напечатать на экране
    with open(filename) as f:
        for line in f.readlines():
            print(line, end="")


# Работу с файлом можно наверное будет потом объединить в отдельный класс
def add_f(param):
    """

    :param param:
    :return:
    """
    # отктыть файл

    # записать задачу в файл

    # сформировать строку задачи (форматировать представление задачи)
    # Может быть задача это тоже отдельный класс?
    # Тогда стоит подумать что должен возвращать класс Param может быть команду и задачу?
    with open(filename, "a") as f:
        f.write(",".join([param.description, param.datetime, param.label]) + "\n")


def del_f(param):
    all_tasks = []
    with open(filename) as f:
        for line in f.readlines():
            all_tasks.append(line)

    with open(filename, "w") as f:
        for task in all_tasks:
            if "," in task:
                describe, dt, label = task.split(",")  # опять работа с видном (представлением) задачи
                if label.strip() != sys.argv[2].strip():  # и заметить что мы забыли убрать в парсинг параметров
                    f.write(task)


class Param:
    def __init__(self, argv):
        self.__argv = argv
        self.command = None
        self.description = None
        self.datetime = None
        self.label = None
        self._parse_argv()

    def _parse_argv(self):
        if "--del" in self._argv:
            self.command = "del"

        if "--add" in self._argv:
            i1 = self._argv.index("--add")
            i2 = self._argv.index("--dt")
            self.command = "add"
            self.description = " ".join(self._argv[i1 + 1:i2]),
            self.datetime = self._argv[i2 + 1],
            self.label = self._argv[i2 + 3],

        if "--list" in self.argv:
            self.command = "list"


if __name__ == "__main__":
    # print(sys.argv)
    filename = "todo.txt"

    param = Param(sys.argv)

    d = {
        "add": add_f,
        "list": list_f,
        "del": del_f,
    }
    d[param.command](param)

# и довести до рабочего состояния как main.py

# все эти изменения мало нужны для одноразовых школьных задач
# и совершенно необходимы для любой задачи которая собирается жить в реальном мире
# потому что реальный мир это постоянные изменения и доработки
# а значит код должен строится таким образом, чтобы каждая отдельная сущность изменялась в максимально локальном
# участке кода. Как например у нас для перехода с одного вида парсинга на другой надо залезть только в один класс
# а вся остальная часть программы остается без изменений

# Это удешевляет поддержку и развитие программ. Даже элементарно на времени тестирования после изменений
# Так как достаточно протестировать класс, который изменили и общую работоспособность, тогда как время и деньги
# на тестирование других частей программы тратить при таком подходе не придется.
